package com.chsoft.common

/**
 * 函数可以被简单的任务是包裹了一条或者几条语句的代码体，该代码接收若干参数，经过代码体处理后返回结果，形如
 * 数学中的f(x)=x+1
 * 在scala中函数式一等公民，可以向变量一样被传递，被赋值，同时函数可以赋值给变量，变量也可以赋值给函数
 * 之所以可以是这样，原因在于函数背后是类和对象，也就是说在运行的时候函数其实就是一个变量！！！当然，背后的类
 * 是scala语言自动帮助我们生成的，且可以天然的被序列号和反序列化，这个意义非常重要：
 * 意义1:可以天然的序列化和反序列化的直接好处就是函数可以在分布式系统上传递
 * 意义2:因为函数背后其实是类和对象，所以可以和普通的变量完全一样的应用在任何普通变量可以运用的地方，包括
 * 作为参数传递，作为返回值，被赋值和赋值给变量等
 * 
 * 补充：整个IT编程技术的发展史，其实就是一部封装史：
 * 1、function时代，在c语言中提供了函数的概念，用函数把若干个语句进行封装和使用
 * 2、class时代，在c++和java等语言中提供了类和对象，把数据和处理数据的业务逻辑封装起来
 * 3、框架时代，把数据、代码和驱动引擎封装起来，是过去10年和未来10年IT技术的核心
 * 
 * 关于函数初级入门的几个要点：
 * 1、def关键字来定义函数
 * 2、函数会自动进行类型推断来确定函数返回值的类型，如果函数名称和函数体之间没有等于号的话则类型推断失效
 * 此时函数的类型是 Unit
 * 3、函数的参数可以是函数
 * 4、如果在函数体中无法推导出函数的类型，则必须声明具体的类型，例如下面的fibonacci：
 * 5、函数的参数可以有默认值这样在调用函数的时候如果不想改变默认值的话直接不传递该参数而是直接使用默认值
 * 即可，这在实际的编程中意义重大，尤其在spark等框架中，因为框架一般都有自己的默认配置和实现，此时我们就可以
 * 非常好的使用默认值；
 * 6、我们可以基于函数的参数的名称来调整函数的传递参数的顺序，重点在于为什么可以这么做呢？原因在于函数背后其实
 * 是类，其参数就是类的成员变量，所以无所谓顺序
 * 7、函数中如果不确定传递参数的个数，可以使用变长参数的方式，传参时候的一个方便的语法是 “ :_* ”
 * 8、可变参数中的数据其实会被收集成Array数组，我们在入口方面main中其实就是可变参数，是以Array[String]
 * 的方式呈现的
 */
object FunctionUtils {
  
  
  def addInt( a:Int, b:Int ) {
      var sum:Int = 0;
      sum = a + b;
      sum;
   }
   
  def main(args: Array[String]) {
    var sum = addInt(5,6);
    println(sum);
    
    
    var total = sums(1,2,3,4,5,6,7,8,9,10)
    var total1 = sums(1 to 10 :_*)   //上面的方式可以简写成，这种方式
    println(total)
    println(total1)
  }
  
   def sums( numbers:Int*):Int={
      if(numbers.length==0) 0
      else {
        println(numbers.head+"===="+numbers.tail);
        numbers.head+sums(numbers.tail:_*) 
      }  //递归的方式
   }
  
  
   def fibonacci( number:Int):Int={
      if(number<=1) 1
      else
       fibonacci(number-2) + fibonacci(number-1) 
   }
  
}